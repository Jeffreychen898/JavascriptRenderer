const $ShaderCode=new Map;$ShaderCode.set("default",{vert:"\nattribute vec3 a_position;\nattribute vec4 a_color;\nattribute vec2 a_texCoord;\n\nuniform mat4 u_projection;\n\nvarying vec4 v_color;\nvarying vec2 v_texCoord;\n\nvoid main() {\n\tv_texCoord = a_texCoord;\n\tv_color = a_color;\n\tgl_Position = u_projection * vec4(a_position, 1.0);\n}\n",frag:"\nprecision mediump float;\n\nvarying vec4 v_color;\nvarying vec2 v_texCoord;\n\nuniform sampler2D u_texture;\n\nvoid main() {\n\tgl_FragColor = texture2D(u_texture, v_texCoord) * vec4(v_color);\n}\n"});let $RendererVariable={WebGL:{Binding:{Shader:void 0,BufferObject:void 0,FrameBuffer:null,TextureSlot:0,Textures:[]},MaxVertexCount:1e4},Texture:{Type:{Image:0,ByteArray:1}},Math:{Type:{Matrix4:0,Vector4:1}}};const Renderer={Uniform:{Integer:0,Float:1,Vector2:2,Vector3:3,Vector4:4,Matrix4:5,IntegerArray:6},MaxTextureSlot:void 0};class $Renderer_Matrix4{constructor(e){if(this.matrix=new Array(16),this.type=$RendererVariable.Math.Type.Matrix4,e)for(const t in e)this.matrix[t]=e[t];else this.identity()}multiply(e){if(e.type!=$RendererVariable.Math.Type.Matrix4&&e.type!=$RendererVariable.Math.Type.Vector4)return void console.error("[ERROR] The Matrix cannot be multiplied");const t=this.multiplyRaw(e.matrix);return e.type==$RendererVariable.Math.Type.Matrix4?new $Renderer_Matrix4(t):e.type==$RendererVariable.Math.Type.Vector4?"Vector class not created yet :(":void 0}multiplyRaw(e){const t=Math.floor(e.length/4);let r=new Array(4*t);for(let i=0;i<4;i++)for(let a=0;a<t;a++){const n=this.matrix[4*i]*e[a],s=this.matrix[4*i+1]*e[1*t+a],o=this.matrix[4*i+2]*e[2*t+a],h=this.matrix[4*i+3]*e[3*t+a];r[i*t+a]=n+s+o+h}return r}transpose(){const e=new Array(16);for(let t=0;t<16;t++){const r=t%4,i=Math.floor(t/4);e[4*r+i]=this.matrix[4*i+r]}this.matrix=e}identity(){for(let e=0;e<16;e++)this.matrix[e]=e%5==0?1:0}inverse(){let e=new Array(16);e[0]=this.$adjugateMatrixValue(5,10,15,11,14,6,9,13,7),e[1]=-this.$adjugateMatrixValue(4,10,15,11,14,6,8,12,7),e[2]=this.$adjugateMatrixValue(4,9,15,11,13,5,8,12,7),e[3]=-this.$adjugateMatrixValue(4,9,14,10,13,5,8,12,6),e[4]=-this.$adjugateMatrixValue(1,10,15,11,14,2,9,13,3),e[5]=this.$adjugateMatrixValue(0,10,15,11,14,2,8,12,3),e[6]=-this.$adjugateMatrixValue(0,9,15,11,13,1,8,12,3),e[7]=this.$adjugateMatrixValue(0,9,14,10,13,1,8,12,2),e[8]=this.$adjugateMatrixValue(1,6,15,7,14,2,5,13,3),e[9]=-this.$adjugateMatrixValue(0,6,15,7,14,2,4,12,3),e[10]=this.$adjugateMatrixValue(0,5,15,7,13,1,4,12,3),e[11]=-this.$adjugateMatrixValue(0,5,14,6,13,1,4,12,2),e[12]=-this.$adjugateMatrixValue(1,6,11,7,10,2,5,9,3),e[13]=this.$adjugateMatrixValue(0,6,11,7,10,2,4,8,3),e[14]=-this.$adjugateMatrixValue(0,5,11,7,9,1,4,8,3),e[15]=this.$adjugateMatrixValue(0,5,10,6,9,1,4,8,2);let t=0;for(let r=0;r<4;r++)t+=this.matrix[r]*e[r];if(console.log(t),0==t)return!1;const r=new Array(16);for(let t=0;t<16;t++){const i=t%4,a=Math.floor(t/4);r[4*i+a]=e[4*a+i]}for(const e in r)this.matrix[e]=r[e]/t;return!0}print(){for(let e=0;e<4;e++){const t=4*e;console.log(this.matrix[t]+" "+this.matrix[t+1]+" "+this.matrix[t+2]+" "+this.matrix[t+3])}}$adjugateMatrixValue(e,t,r,i,a,n,s,o,h){const u=this.matrix;return u[e]*(u[t]*u[r]-u[i]*u[a])-u[n]*(u[s]*u[r]-u[i]*u[o])+u[h]*(u[s]*u[a]-u[t]*u[o])}}function $Renderer_RotateZMatrix(e,t){const r=[Math.cos(t),-Math.sin(t),0,0,Math.sin(t),Math.cos(t),0,0,0,0,1,0,0,0,0,1];return new $Renderer_Matrix4(e.multiplyRaw(r))}function $Renderer_TranslateMatrix(e,t,r,i){i||(i=0);const a=[1,0,0,t,0,1,0,r,0,0,1,i,0,0,0,1];return new $Renderer_Matrix4(e.multiplyRaw(a))}function $Renderer_ScaleMatrix(e,t,r,i){i||(i=1);const a=[t,0,0,0,0,r,0,0,0,0,i,0,0,0,0,1];return new $Renderer_Matrix4(e.multiplyRaw(a))}function $Renderer_Camera2D(e,t,r,i){return new $Renderer_Matrix4([2/(t-e),0,0,-(t+e)/(t-e),0,2/(r-i),0,-(r+i)/(r-i),0,0,1,0,0,0,0,1])}class $Renderer_TextureBuffer{constructor(e,t,r){this.$m_gl=e,this.width=t,this.height=r,this.defaultCamera=new $Renderer_Camera2D(0,t,0,r),this.$m_framebuffer,this.$m_texture,this.$m_renderbuffer}create(){const e=this.$m_gl;this.$m_framebuffer=e.createFramebuffer(),e.bindFramebuffer(e.FRAMEBUFFER,this.$m_framebuffer),this.$m_texture=e.createTexture(),e.bindTexture(e.TEXTURE_2D,this.$m_texture),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,this.width,this.height,0,e.RGBA,e.UNSIGNED_BYTE,null),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST);const t=$RendererVariable.WebGL.Binding.TextureSlot,r=$RendererVariable.WebGL.Binding.Textures[t];e.bindTexture(e.TEXTURE_2D,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,this.$m_texture,0),this.$m_renderbuffer=e.createRenderbuffer(),e.bindRenderbuffer(e.RENDERBUFFER,this.$m_renderbuffer),e.renderbufferStorage(e.RENDERBUFFER,e.DEPTH_STENCIL,this.width,this.height),e.bindRenderbuffer(e.RENDERBUFFER,null),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.DEPTH_STENCIL_ATTACHMENT,e.RENDERBUFFER,this.$m_renderbuffer),e.bindFramebuffer(e.FRAMEBUFFER,$RendererVariable.WebGL.Binding.FrameBuffer)}bind(){if($RendererVariable.WebGL.Binding.FrameBuffer!=this.$m_framebuffer){const e=this.$m_gl;e.bindFramebuffer(e.FRAMEBUFFER,this.$m_framebuffer),e.viewport(0,0,this.width,this.height),$RendererVariable.WebGL.Binding.FrameBuffer=this.$m_framebuffer}}setCamera(e,t){e.flush(),this.defaultCamera=t}bindTexture(e){const t=this.$m_gl;if(!Renderer.MaxTextureSlot)return void console.error("[ERROR] Renderer has not been initialized properly!");if(e>Renderer.MaxTextureSlot)return void console.error(`[ERROR] The max texture slot of ${Renderer.MaxTextureSlot} has been reached`);const r=$RendererVariable.WebGL.Binding.TextureSlot;$RendererVariable.WebGL.Binding.Textures[e]!=this.$m_texture&&(e!=r&&(t.activeTexture(t.TEXTURE0+e),$RendererVariable.WebGL.Binding.TextureSlot=e),t.bindTexture(t.TEXTURE_2D,this.$m_texture),$RendererVariable.WebGL.Binding.Textures[r]=this.$m_texture)}}function $Renderer_BindDefaultFrameBuffer(e){null!=$RendererVariable.WebGL.Binding.FrameBuffer&&(e.bindFramebuffer(e.FRAMEBUFFER,null),$RendererVariable.WebGL.Binding.FrameBuffer=null)}class $Renderer_Shader{constructor(e,t,r,i,a){this.$m_gl=e,this.$createProgram(t,r),this.$setupAttribute(i),a&&this.$setupUniform(a),this.$setupIndexBuffer(),this.bind()}setAttribData(e,t){const r=this.$m_gl;if(this.$m_attributeLocations.has(e)){this.bind();const i=this.$m_attributeLocations.get(e);i!=$RendererVariable.WebGL.Binding.BufferObject&&(r.bindBuffer(r.ARRAY_BUFFER,i),$RendererVariable.WebGL.Binding.BufferObject=i),r.bufferData(r.ARRAY_BUFFER,new Float32Array(t),r.DYNAMIC_DRAW)}}setIndices(e){const t=this.$m_gl;this.bind(),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.$m_ibo),$RendererVariable.WebGL.Binding.BufferObject=this.$m_ibo,t.bufferData(t.ELEMENT_ARRAY_BUFFER,new Uint16Array(e),t.DYNAMIC_DRAW)}setUniform(e,t){const r=this.$m_gl;if(this.bind(),this.$m_uniformLocations.has(e)){this.$m_uniformData.set(e,t);const i=this.$m_uniformLocations.get(e),a=i.type;a==Renderer.Uniform.Float?r.uniform1f(i.location,t):a==Renderer.Uniform.Vector2?r.uniform2f(i.location,...t):a==Renderer.Uniform.Vector3?r.uniform3f(i.location,...t):a==Renderer.Uniform.Vector4?r.uniform4f(i.location,...t):a==Renderer.Uniform.Matrix4?r.uniformMatrix4fv(i.location,!0,t):a==Renderer.Uniform.Integer?r.uniform1i(i.location,t):a==Renderer.Uniform.IntegerArray&&r.uniform1iv(i.location,t)}}bind(){const e=this.$m_gl;$RendererVariable.WebGL.Binding.Shader!=this.$m_program&&(e.useProgram(this.$m_program),e.bindVertexArray(this.$m_vao),$RendererVariable.WebGL.Binding.Shader=this.$m_program)}$setupIndexBuffer(){const e=this.$m_gl;this.$m_ibo=e.createBuffer(),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.$m_ibo),$RendererVariable.WebGL.Binding.BufferObject=this.$m_ibo}$setupAttribute(e){const t=this.$m_gl;this.$m_vao=t.createVertexArray(),t.bindVertexArray(this.$m_vao),this.$m_attributeLocations=new Map;for(const r of e){const e=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,e),$RendererVariable.WebGL.Binding.BufferObject=e;const i=t.getAttribLocation(this.$m_program,r.name);this.$m_attributeLocations.set(r.name,e),t.vertexAttribPointer(i,r.size,t.FLOAT,!1,0,0),t.enableVertexAttribArray(i)}}$setupUniform(e){const t=this.$m_gl;this.$m_uniformLocations=new Map;for(const r of e){const e=t.getUniformLocation(this.$m_program,r.name);this.$m_uniformLocations.set(r.name,{location:e,type:r.type})}this.$m_uniformData=new Map}$createProgram(e,t){const r=this.$m_gl,i=this.$compileShader(r.VERTEX_SHADER,e),a=this.$compileShader(r.FRAGMENT_SHADER,t);this.$m_program=r.createProgram(),r.attachShader(this.$m_program,i),r.attachShader(this.$m_program,a),r.linkProgram(this.$m_program),r.getProgramParameter(this.$m_program,r.LINK_STATUS)||console.error(`[ERROR] Linking Shader Program ${r.getProgramInfoLog(this.$m_program)}`)}$compileShader(e,t){const r=this.$m_gl,i=r.createShader(e);return r.shaderSource(i,t),r.compileShader(i),r.getShaderParameter(i,r.COMPILE_STATUS)||console.error(`[ERROR] Compiling Shader ${r.getShaderInfoLog(i)}`),i}}class Texture{constructor(e,t){this.$m_gl=e,this.$m_type="string"==typeof t?$RendererVariable.Texture.Type.Image:$RendererVariable.Texture.Type.ByteArray,this.$m_source=t}load(e){const t=new Image;t.onload=()=>{const r=this.$createCanvas(t.width,t.height,t);this.$createWebGLImage(r,{width:r.width,height:r.height}),"function"==typeof e&&e()},t.src=this.$m_source,t.setAttribute("crossOrigin","")}createTexture(e){this.$createWebGLImage(this.$m_source.data,{width:this.$m_source.width,height:this.$m_source.height}),"function"==typeof e&&e()}bindTexture(e){const t=this.$m_gl;if(!Renderer.MaxTextureSlot)return void console.error("[ERROR] Renderer has not been initialized properly!");if(e>Renderer.MaxTextureSlot)return void console.error(`[ERROR] The max texture slot of ${Renderer.MaxTextureSlot} has been reached`);const r=$RendererVariable.WebGL.Binding.TextureSlot;$RendererVariable.WebGL.Binding.Textures[e]!=this.$m_texture&&(e!=r&&(t.activeTexture(t.TEXTURE0+e),$RendererVariable.WebGL.Binding.TextureSlot=e),t.bindTexture(t.TEXTURE_2D,this.$m_texture),$RendererVariable.WebGL.Binding.Textures[r]=this.$m_texture)}$createWebGLImage(e,t){const r=this.$m_gl,i=r.createTexture();this.$m_texture=i,this.bindTexture(0),r.texImage2D(r.TEXTURE_2D,0,r.RGBA,t.width,t.height,0,r.RGBA,r.UNSIGNED_BYTE,e),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.LINEAR),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,r.NEAREST)}$createCanvas(e,t,r){const i=document.createElement("canvas");i.width=e,i.height=t;const a=i.getContext("2d");return a.scale(1,-1),a.drawImage(r,0,-i.height),i}}const $R={Create:{Renderer:e=>new $Renderer_Main(e),Matrix4:e=>new $Renderer_Matrix4(e),Camera2D:(e,t,r,i)=>new $Renderer_Camera2D(e,t,r,i)},Apply:{Rotation:(e,t)=>$Renderer_RotateZMatrix(e,t),Translate:(e,t,r,i)=>$Renderer_TranslateMatrix(e,t,r,i),Scale:(e,t,r,i)=>$Renderer_ScaleMatrix(e,t,r,i)}};let drawcall=0;class $Renderer_Main{constructor(e){this.$m_canvas=document.getElementById(e.canvas),this.$m_gl=this.$m_canvas.getContext("webgl2"),this.$m_properties={canvasSize:{width:e.canvasWidth||this.$m_canvas.width,height:e.canvasHeight||this.$m_canvas.height}},this.$m_vertexCount=0,this.$m_attributesTracker=new Map,this.$m_attributes=[],this.$m_indices=[],this.$setupRendering(),this.$loadDefaultTextures(),this.draw={rect:(e,t,r,i,a)=>{a||(a={}),this.$drawImage(this.$m_whiteTexture,e,t,r,i,a)},image:(e,t,r,i,a,n)=>{n||(n={}),this.$drawImage(e,t,r,i,a,n)},shader:(e,t,r,i,a,n,s)=>{s||(s={})},vertex:(e,t,r)=>{this.$setVertex(e,t,r)},shape:e=>{this.$drawShape(e)}},this.create={texture:e=>{const t=new Texture(this.$m_gl,e);return t.load(),t},shader:(e,t,r,i)=>new $Renderer_Shader(this.$m_gl,e,t,r,i),textureBuffer:(e,t)=>{const r=new $Renderer_TextureBuffer(this.$m_gl,e,t);return r.create(),r},shape:(e,t)=>this.$createShape(e,t)}}flush(){this.$m_vertexCount>0&&this.$render(this.$m_currentBoundProgram)}setCamera(e){this.flush(),this.$m_defaultCamera=e,this.$m_shaderProgram.setUniform("u_projection",e.matrix)}resizeCanvas(e,t,r){null==r&&(r=!0),this.$m_canvas.width=e,this.$m_canvas.height=t,this.$m_properties.canvasSize.width=e,this.$m_properties.canvasSize.height=t,null==$RendererVariable.WebGL.Binding.FrameBuffer&&this.$m_gl.viewport(0,0,e,t),r&&this.setCamera(new $Renderer_Camera2D(0,e,0,t))}$createShape(e,t){if(!t){let r=[1,1,1,1];if(e.color)switch(e.color.length){case 1:r=[e.color[0]/255,e.color[0]/255,e.color[0]/255,1];break;case 2:r=[e.color[0]/255,e.color[0]/255,e.color[0]/255,e.color[1]/255];break;case 3:r=[e.color[0]/255,e.color[1]/255,e.color[2]/255,1];break;case 4:r=[e.color[0]/255,e.color[1]/255,e.color[2]/255,e.color[3]/255]}e.color=r,e.texture||(e.texture=[this.$m_whiteTexture]),0==e.texture.length&&(e.texture=[this.$m_whiteTexture]),t=this.$m_shaderProgram}return{properties:e,shader:t||null,vertices:[]}}$setVertex(e,t,r){if(r||(r=[]),e.shader==this.$m_shaderProgram){let t=!1,i=!1;for(const e of r)"a_color"==e.name?t=!0:"a_texCoord"==e.name&&(i=!0);t||r.push({name:"a_color",values:e.properties.color}),i||r.push({name:"a_texCoord",values:[0,0]})}const i=[...r,{name:e.properties.position||"a_position",values:[t.x,t.y,t.z||0]}];e.vertices.push(i)}$drawShape(e){if(e.vertices.length<3)return;let t=!1;if(e.properties.textureBuffer?$RendererVariable.WebGL.Binding.FrameBuffer==e.properties.textureBuffer.$m_framebuffer||t||(this.flush(),t=!0,e.properties.textureBuffer.bind(),this.$m_shaderProgram.setUniform("u_projection",e.properties.textureBuffer.defaultCamera.matrix)):null==$RendererVariable.WebGL.Binding.FrameBuffer||t||(this.setCamera(this.$m_defaultCamera),t=!0,$Renderer_BindDefaultFrameBuffer(this.$m_gl),this.$m_gl.viewport(0,0,this.$m_properties.canvasSize.width,this.$m_properties.canvasSize.height)),e.properties.texture)for(let r=0;r<e.properties.texture.length;r++)$RendererVariable.WebGL.Binding.Textures[r]!=e.properties.texture[r].$m_texture&&(t||(this.flush(),t=!0),e.properties.texture[r].bindTexture(r));(e.shader!=this.$m_currentBoundProgram||this.$m_vertexCount+4>$RendererVariable.WebGL.MaxVertexCount)&&this.$render(this.$m_currentBoundProgram);const r=e.properties.position||"a_position";for(let t=0;t<e.vertices.length;t++)for(let i=0;i<e.vertices[t].length;i++){if(e.vertices[t][i].name==r&&e.properties.transformation){const r=e.properties.transformation.multiplyRaw([...e.vertices[t][i].values,1]);e.vertices[t][i].values[0]=r[0],e.vertices[t][i].values[1]=r[1],e.vertices[t][i].values[2]=r[2]}const a=this.$m_attributesTracker.get(e.vertices[t][i].name);"number"==typeof a?this.$m_attributes[a].content.push(...e.vertices[t][i].values):(this.$m_attributesTracker.set(e.vertices[t][i].name,this.$m_attributes.length),this.$m_attributes.push({name:e.vertices[t][i].name,content:[...e.vertices[t][i].values]}))}for(let t=2;t<e.vertices.length;t++)this.$m_indices.push(this.$m_vertexCount,this.$m_vertexCount+t-1,this.$m_vertexCount+t);this.$m_vertexCount+=e.vertices.length,this.$m_currentBoundProgram=e.shader}$drawImage(e,t,r,i,a,n){n.texture=[e];const s=this.$createShape(n);this.$setVertex(s,{x:t,y:r},[{name:"a_texCoord",values:[0,1]}]),this.$setVertex(s,{x:t+i,y:r},[{name:"a_texCoord",values:[1,1]}]),this.$setVertex(s,{x:t+i,y:r+a},[{name:"a_texCoord",values:[1,0]}]),this.$setVertex(s,{x:t,y:r+a},[{name:"a_texCoord",values:[0,0]}]),this.$drawShape(s)}$render(e){const t=this.$m_gl;for(const t of this.$m_attributes)e.setAttribData(t.name,t.content);e.setIndices(this.$m_indices),e.bind(),t.drawElements(t.TRIANGLES,this.$m_indices.length,t.UNSIGNED_SHORT,0),this.$clearAttribs(),this.$m_vertexCount=0}$clearAttribs(){this.$m_attributes=[],this.$m_indices=[],this.$m_attributesTracker=new Map}$loadDefaultTextures(){const e={data:new Uint8Array([255,255,255,255]),width:1,height:1};this.$m_whiteTexture=new Texture(this.$m_gl,e),this.$m_whiteTexture.createTexture()}$setupRendering(){const e=this.$m_gl;e.enable(e.DEPTH_TEST),e.depthFunc(e.LEQUAL),e.enable(e.BLEND),e.blendFunc(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA),Renderer.MaxTextureSlot=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),e.clearColor(0,0,0,1),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT);const t=[{name:"u_projection",type:Renderer.Uniform.Matrix4},{name:"u_texture",type:Renderer.Uniform.Integer}],r=this.$m_properties.canvasSize.width,i=this.$m_properties.canvasSize.height;this.$m_defaultCamera=new $Renderer_Camera2D(0,r,0,i),this.$m_shaderProgram=new $Renderer_Shader(e,$ShaderCode.get("default").vert,$ShaderCode.get("default").frag,[{name:"a_position",size:3},{name:"a_color",size:4},{name:"a_texCoord",size:2}],t),this.$m_shaderProgram.setUniform("u_projection",this.$m_defaultCamera.matrix),this.$m_shaderProgram.setUniform("u_texture",0),this.$m_shaderProgram.bind(),this.$m_currentBoundProgram=this.$m_shaderProgram}}
